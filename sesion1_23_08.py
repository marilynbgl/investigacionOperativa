# -*- coding: utf-8 -*-
"""sesion1-23-08.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W85iZYpNSDRP0kvwW-eMQXLwdCPqY0S2

# INTRODUCCION A PROGRAMACION

## PRIMERA CLASE

#TIPO DE DATOS INTEGRADOS(PRIMITIVOS)

Tipo     |  Descripcion
---------|-----------------
string   | cadena de texto
int      | mumero entero
float    | numero real
bool     | booleano
"""

nom="alfredoos"
type(nom)

"""## ** operadores aritmeticos y opeardores logicos**

DESCRIPCION     | OPERADOR
----------------|----------
SUMA            |  +
DIFERENCIA      |  -
POTENCIA        | **
MODULO          | %
DISYUNCION      | or
CONJUNCION      | and
NEGACION        | not

# ** INSERCION DE CODIGO LATEX**

$\frac{a}{b+c}$

$x+y+\mathcal{T}$

## FUNCIONES INTEGRADAS**
complex que convierte a numero complejo
[ejemplo de link](https://)
pow = potencia
abs = absoluto

# FUNCIONES MATEMATICAS DEL MODULO MATH

## ** MODULO MATH**
"""

import math #carga el modulo de funciones math

math.gcd(8,4) # saca el maximo comun divisor
math.exp(1) # funcion exponencial con base e

"""## Estructura de datos en python **

https://towardsdatascience.com/which-python-data-structure-should-you-use-fa1edd82946c)
<img src="https://miro.medium.com/max/1400/1*2JFd94q0vzsEcr-LB-220g.png

##LISTA **
Estructura que permte almacenar elementos de diferentes tipos.
"""

lista1=[1,"jorge", True] # esto es un objeto de la estructra lista
print(type(lista1))
print(lista1[0])
print(lista1[1])
print(lista1[2])

lista2=[255,"pepe",lista1] #lista dentro de lista
print(lista2[0])
print(lista2[1])
print(lista2[2][1]) # acccediendo al elemento con indice 1 dele elemento con indice 2 de la lista 2

"""## **METODOS Y FUNCIONES PARA LISTAS**"""

#UN METODO ES UNA FUNCIÓN QUE "PERTENECE" A UN OBJETO
edades=[25,23,12,45,13,23]
edades.sort()
edades.sort(reverse=True) #invierte a descendente el orden
print(edades)
edades.append(100)
print(edades)
edades.sort()
print(edades)

edades.count(23) # el metodo count devuelve el número de ocurrencias de un objeto dentro de una lista

edades2=[25,23,12,45,13,23]
edades3= sorted(edades2) #funcion "sorted" incorporada en python
print(edades2)
print(edades3)

pesos=[20.5,33.0,12.3,18.7]
pesos.sort(reverse=True)
print(pesos)

poligonos=["triangulo","cuadrado", "trapecio"]
print(poligonos)
poligonos.append("rombo")
poligonos.reverse()
print(poligonos)

otros=["hexagono","pentagono"]
poligonos.append(otros)
poligonos.insert(0,"rectangulo")
print(poligonos)

poligonos.remove("cuadrado")
print(poligonos)

len(poligonos)

lista3=["a","b","c"]
lista4=["d","e"]
concat1= lista3+lista4
print(concat1)
concat2= lista4+lista3
print(concat2)

print(lista3)
lista3[0]=123 #modificando la entrada 0 de lista3
print(lista3)

"""## TUPLA
estructura similar a la estructura lista, sin embargo es inmutable
"""

tupla=("a","b","c")
print(type(tupla))
print(tupla[0])
tupla.index("c")

print("esto", tupla,"es una tupla\n")
tupla.index("b")

"""## RANGO
ESTRUCTURA PARA ALMACENAR SUCESIONES FINITS DE NUMEROS ENTEROS. ES INMUTABLE
"""

sucesion=range(7)
print(type(sucesion))
print(sucesion)
print(sucesion[0])
print(sucesion[1])
print(sucesion[2])
print("el objeto de la sucesion tiene",len(sucesion),"elementos")
rango=range(3,7)
print(rango)
print(rango[0])
print(rango[1])
print(rango[2])
print(rango[3])
print(rango.stop) #imprime el ultimo numero +1 ene este caso
rango=range(3,7,2)# el 2 indica la razon de aumento 2 en 2
print(rango)
print(rango[0])
print(rango[1])
#print(rango[2])
print(rango.stop) # imprime 7

"""## MATRICES

"""

import numpy as np
m1=np.array([[5,0,1],[3,1,1],[0,1,2]])
print(m1)

matriz1 = np.array([[1., 2., 3.],[4., 5., 6.],[7.,8.,9.]])
print("Matriz original:\n", matriz1)
print(matriz1.dtype) # me da el tipo de datos que tiene mi matriz
matriz2= np.array([[1., 2., 3.],[4., 5., 6.]],dtype=np.float64)
transpuesta=matriz1.T
print(transpuesta)
traza=matriz1.trace()#hallando traza por medio de un objeto llamar su metodo
traza1=matriz1[0,0]+matriz1[1,1]+matriz1[2,2]
traza2=np.trace(matriz1)# de la libreria numpy tiene una funcion y se le debe poner el objeto a evaluar
print(traza, traza1, traza2)

sumMatriz= matriz1 + m1
print(sumMatriz)
matrizProducto=np.dot(matriz1,m1)
matrizPro2= np.matmul(matriz1,m1) #mas eficiente computacionalmente en costo
matrizPro3= matriz1 @ m1
print("matrizproducto= \n", matrizProducto, "\n matrizpro2=\n",matrizPro2,"\n matrizpro3=\n",matrizPro3 )
print(matriz1.dot(m1))

#ejercicio de la suma de matrices con codigo
import numpy as np

def suma(m1,m2):
    resultado = np.zeros_like(m1)

    for i in range(len(m1)):
       for j in range(len(m1[0])):
        resultado[i][j]=m1[i][j] + m2[i][j]
    return resultado

# Generar una matriz de nxn con enteros entre 0 y 9 (el 100 no está incluido)
a= int(input("ingresa el orden de la matriz:"))
matriz1 = np.random.randint(0, 100, size=(a, a))
matriz2 = np.random.randint(0,100,size=(a,a))
print("matriz 1:\n", matriz1)
print("matriz 2:\n", matriz2)
print("\n suma es:\n",suma(matriz1,matriz2))

#ingresando datos para dos matrices y que tengan la misma dimension
import numpy as np

def suma(m1,m2):
    # Verifica si las matrices tienen las mismas dimensiones
    if len(m1) != len(m2) or len(m1[0]) != len(m2[0]):
        return "Error: Las matrices deben tener las mismas dimensiones para sumarse."
    resultado = np.zeros_like(m1)
    for i in range(len(m1)):
       for j in range(len(m1[0])):
        resultado[i][j]=m1[i][j] + m2[i][j]
    return resultado

# Generar una matriz de nxn con enteros entre 0 y 9 (el 100 no está incluido)
a= int(input("ingresa el numero de filas para matriz1:"))
b= int(input("ingresa el numero de columnas para matriz 1 :"))
c= int(input("ingresa el numero de filas para matriz 2:"))
d= int(input("ingresa el numero de columnas para matriz 2:"))
matriz1 = np.random.randint(0, 100, size=(a, b))
matriz2 = np.random.randint(0,100,size=(c,d))
#f= len(matriz1) #numero de filas de la matriz
#c= len(matriz1[0]) #numero de columnas de la matriz
#print("numero de filas:",f )
#print("numero de columnas:", c)
print("matriz 1:\n", matriz1)
#print("\n")
print("matriz 2:\n", matriz2)
print("\n suma es:\n",suma(matriz1,matriz2))

vect2=np.linspace(2,6,7)
print(vect2)

mat2=np.random.rand(3,3)# llena matriz de datoas aleatorios
print(mat2)

mat3=np.empty((3,3),dtype=np.float32) #una matriz vacia con orden 3 de tipo de dato float32
print(mat3)
mat3[0][0]= np.pi
print(mat3)